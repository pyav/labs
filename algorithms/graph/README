Graph Representation:
--------------------
In practice: Use adjacency list representation.
             - Algorithms based on iterating over vertices adjacent to 'v'.
             - Real-world graphs tend to be sparse (huge number of vertices,
               small average vertex degree).

--------------------------------------------------------------------------
Representation | Space | Add Edge | Edge between | Iterate over vertices |
               |       |          | v and w      | adjacent to v?        |
--------------------------------------------------------------------------
List of edges  |   E   |    1     |     E        |      E                |
--------------------------------------------------------------------------
Adjacency      |  V^2  |    1*    |     1        |      V                |
Matrix         |       |          |              |                       |
--------------------------------------------------------------------------
Adjacency      | E + V |    1     |  degree(v)   |      degree(v)        |
List           |       |          |              |                       |
--------------------------------------------------------------------------
                                                * disallows parallel edges

Maze exploration:
----------------
  - Depth First Search - eg, Pacman game.

Depth-first search:
------------------
  - Goal: Systematically search through a graph.
  - Idea: Mimic maze exploration.
  - DFS(to visit a vertex v):
    ---
      - Mark v as visited.
      - Recursively visit all unmarked vertices 
        w adjacent to v.
  - Typical applications:
    --------------------
      - Find all vertices connected to a given source vertex.
      - Find a path between two vertices.

Bread-first search:
------------------
  - Not a recursive algorithm, but uses a queue as an auxiliary data structure.
  - Shortest Path.
  - BFS(from source vertex s):
    ---
      - Put 's' onto a FIFP queue and mark 's' as visited.
      - Repeat until the queue is empty:
          - Remove the least recently added vertex v.
          - Add each of v's unvisited neighbors to the queue and mark them as
            visited.
  - BFS computes shortest paths (fewest number of edges) from 's' to all other
    vertices in a graph in time proportional to E + V.
  - Routing: Fewest number of hops in a communication network.
  - Kavin Bacon Numbers.
  - Erdos numbers.


Connected Components:
--------------------
  - The relation "is connected to" is an equivalence relation.
    - Reflexive: v is connected to v.
    - Symmetric: if v is connected to w, then w is connected to v.
    - Transitive: if v is connected to w and w is connected to x, then v is
                  connected to x.
  - Goal: Partition vertices into connected components.
          - Initialize all vertices v as unmarked.
          - For each unmarked vertex, run DFS to identify all vertices
            discovered as part of the same component.
          - Keep track of connected component number.
          - Connected component groups help process the data in linear time.

Graph Challenges:
----------------
  - Challenge 1: Is a graph bipartite?
  - Challenge 2: Find a cycle.
  - Challenge 3: Euler Tour: Is there a cycle that uses each edge exactly once?
                 => A connected graph is Eulerian iff all the vertices have
                    even degree.
  - Challenge 4: Find a cycle that visits every vertex exactly once.
                   - Sometimes called as Traveling sales person problem in graph.
                 => Hamiltonian cycle problem (Classical NP-complete problem).
                    - Intractable.
  - Challenge 5: Are two graphs identical except for vertex names?
                 => Graph Isomorphism Problem.
                 - No body knows even how to classify this problem.
  - Challenge 6: Layout a graph in a plane without crossing edges?
                 => Linear time DFS based planarity algorithm. Discoverd by
                    Tarjan in 1970s. (too complicated for most practioners).


Directed Graph (or Digraph):
---------------------------
Some diagraph problems:
----------------------
  - Path: Is there a directed path from one point to another in a directed graph?
  - Shorted Path: What is the shorted directed path from s to t?
  - Topological sort: Can you draw a digraph so that all edges point upwards?
  - Strong connectivity: Is there a directed path between all pairs of
                         vertices?
  - Transitive closure: For which vertices v and w is there a path from v to w?
  - PageRank: What is the importance of a web page?

Digraph API:
-----------



