Graph Representation:
--------------------
In practice: Use adjacency list representation.
             - Algorithms based on iterating over vertices adjacent to 'v'.
             - Real-world graphs tend to be sparse (huge number of vertices,
               small average vertex degree).

--------------------------------------------------------------------------
Representation | Space | Add Edge | Edge between | Iterate over vertices |
               |       |          | v and w      | adjacent to v?        |
--------------------------------------------------------------------------
List of edges  |   E   |    1     |     E        |      E                |
--------------------------------------------------------------------------
Adjacency      |  V^2  |    1*    |     1        |      V                |
Matrix         |       |          |              |                       |
--------------------------------------------------------------------------
Adjacency      | E + V |    1     |  degree(v)   |      degree(v)        |
List           |       |          |              |                       |
--------------------------------------------------------------------------
                                                * disallows parallel edges

Maze exploration:
----------------
  - Depth First Search - eg, Pacman game.

Depth-first search:
------------------
  - Goal: Systematically search through a graph.
  - Idea: Mimic maze exploration.
  - DFS(to visit a vertex v):
    ---
      - Mark v as visited.
      - Recursively visit all unmarked vertices 
        w adjacent to v.
  - Typical applications:
    --------------------
      - Find all vertices connected to a given source vertex.
      - Find a path between two vertices.

Bread-first search:
------------------
  - Not a recursive algorithm, but uses a queue as an auxiliary data structure.
  - Shortest Path.
  - BFS(from source vertex s):
    ---
      - Put 's' onto a FIFP queue and mark 's' as visited.
      - Repeat until the queue is empty:
          - Remove the least recently added vertex v.
          - Add each of v's unvisited neighbors to the queue and mark them as
            visited.
  - BFS computes shortest paths (fewest number of edges) from 's' to all other
    vertices in a graph in time proportional to E + V.
  - Routing: Fewest number of hops in a communication network.
  - Kavin Bacon Numbers.
  - Erdos numbers.


Connected Components:
--------------------
  - The relation "is connected to" is an equivalence relation.
    - Reflexive: v is connected to v.
    - Symmetric: if v is connected to w, then w is connected to v.
    - Transitive: if v is connected to w and w is connected to x, then v is
                  connected to x.
  - Goal: Partition vertices into connected components.
          - Initialize all vertices v as unmarked.
          - For each unmarked vertex, run DFS to identify all vertices
            discovered as part of the same component.
          - Keep track of connected component number.
          - Connected component groups help process the data in linear time.
  - 







