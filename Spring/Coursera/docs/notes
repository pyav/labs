Notes from Coursera: (Dr. Jules White) - https://www.coursera.org/learn/cloud-services-java-spring-framework/home/welcome
===================

Request body encoding:
---------------------
Request message  --> body ---> url encoded (small amounts, simple key-value pairs)
                          |
                          |--> multi part (Lots of data, files)

Http response anatomy:
---------------------
  Status line:
  -----------
  response   phrase
    code      or
             text

  Header:
  ------
    Content-type
    Body

Http response code:
------------------
       logic ---> 1xx - info
         |   |--> 2xx - success 
         |   |     |-> 200 - OK
         |   |--> 3xx - redirection
         |   |--> 4xx - client error
         |   |     |-> 404 - resource not found
         |   |--> 5xx - server error
         |         |-> 500
         V
       handle
       response
       based
       on 
       code

Cookies:
-------
  Server --> cookies --> response
                         header
                           |
                           V
                         Client stores
                          and 
                         sends to Server

Http polling:
------------
  - Regular http client needs to poll server as http is a client-driven
    protocol. This has some time fixed to it, which can be increased, say after
    T seconds and then after 2T seconds and so on. 
  - The client connection can be upgraded to Websockets in which the server can
    send back the data to client. Problem with Websockets is that if the
    connection is dropped, the client needs to reconnect and upgrade to
    Websocket. This means some kind of logic needs to be with client to
    understand and figure out when the connection went off and reconnect and
    then upgrade to websocket.
  - Another issue with wesockets is that a persistent connection needs to be
    present with a client always. This means that server resources will be in
    use constantly. For an http connection, the server can let go the
    connection if there is no data.

Push messaging:
--------------
  client        server            GCM (Google Cloud Messaging)
    |             |--------------->|
    |<---msg, who subs?, <4Kb------|
    |             |                |
    |--poll------>|                |
    |<------------|                |
        ^
        |
     control data
        +
     security

Example Servlet: (video servlet)
---------------
            selection of servlet (web.xml)
               |
 Request    --------------------------
 method     |  |  video servlet       |
----------->|- V  -----------         |
            ||--->| doPost()|         |
            |     | doGet()-|--         |
            |     |---------| |        |
            ------------------|--------
              setContentType()|PrintWriter.write()
                              V
                            Client

Injection Attacks:
-----------------
  - Don't directly execute commands sent by clients.
  - Don't blindly trust client's data. Segregate it and make sure it can't
    manipulate the server in some way. Validate it.
  - If the client's data has a potential to get executed, server must sanitize
    it and strip out anything bad in it. Best approach is to allow only a
    certain items.
  - Always validate the type of data sent from client to be of the type it is
    supposed to be, to be in the range it is supposed to be.
  - Be very careful of the data that the server sends back to the client.
  - Make sure that anything that comes to the server doesn't lead to any attack
    on the server or the client visiting the server. Same goes for anything
    that leaves the server.

Dispatcher and controller abstraction:
-------------------------------------
  - register controller
  - Xml or Java annotations
  - routing of request
  - dispatcher servlet - routing, data extraction, marshalling and validation.

Spring controllers:
------------------
  - @Controller for class.
  - @RequestMapping(value="<path>", method=RequestMethod.<POST/GET>) for method.
  - @RequestParam("<key>")
  - @PathVar("<key>")
  - @RequestBody - whenever this annotation is seen, http message converter
    takes care of constructing an object and mapping the request parameters to
    the data members of that object type i.e. class.
  - MultipartFile for data strems:
    -----------------------------
      - public String func(@RequestParam("file") MultipartFile file) {}
  - @Bean - MultipartConfigElement
  - @ResponseBody - Spring looks at the return type and makes it a part of the
                    response body.

Marshalling with Jackson Annotations:
------------------------------------
  - ObjectMapper - converts object to and from json.
  - @JsonIgnore - to tell Jackson to ignore a property.

Spring Boot:
-----------
  - setup web container
  - discover our controllers
  - setup dispatcher servlet
  - connecting to dbs, etc.

Spring Controller:
-----------------
  - Web container has dispatcher servlets which are associated with
    controllers.
  - @Configuration - Tell Spring that this object represents a configuration
                     for the application.
  - @EnableWebMvc - Tell Spring to turn on web MVC(e.g. it should enable
                    Dispatcher Servlet so that requests can be routed to our
                    controller).
  - @ComponentScan("org...controller") - Tell Spring to scan controller package
                                         (and all sub-packages) to find any
                                         controllers or other component part of
                                         the Application - @Controller classes
                                         are attached to the dispatcher servlet.
  - EnableAutoConfiguration - Tell Spring to inject depenencies that are marked
                              in our classes with @Autowired.
  - SpringApplication.run(Application.class, args) - To launch the application.

Horizontal Scaling:
------------------
  - Adding servers to the application may not increase the power to process
    requests per second in equal proportion of the servers. There could be
    multiple reasons for this, one is the application being stateful. This
    could also be with the servers. In this case the new server needs to first
    have the state of the application. Hence, the thoughts should be towards
    designing stateless applications as much as we can.

HTTP Load Balancing:
-------------------
 - One of the simple ways to load balance the incoming requests over a set of
   servers is to do a round-robin request distribution. Challenge here would be
   to sync required metadata (state) like login information across servers. So
   when the request is routed to the next server, it will ask for login
   credential again.
 - Stateful and stateless application. In stateful application, we do maintain
   a state of the client talking to a a particular server and we route that
   client's request to that server only. This is "Sticky session(s)".
 - We can also keep a state in a lower layer central db. Each server machine
   checks whether a particular client has logged in from that db.
 - State can also be distributed across multiple machines either using
   distributed in memory cache like memcached or database that is connected to
   all the machines and you have a mechanism to distribute the state.


